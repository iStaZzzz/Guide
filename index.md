---
layout: default
---

<h2>Хороший код</h2>
  <p>Прежде чем писать хороший код, нужно определиться, что считать хорошим. 
  Универсальное правило: мой код хороший, код моего коллеги (особенно тот, что достался в “наследство”) - плохой. 
  Эту шутку можно сказать другими словами: чем больнее мне работать с кодом, тем он хуже. 
  Под работой я понимаю как добавление функционала, так и поиск бага, так и просто открыть, 
  посмотреть на логику (это важное уточнение: изолированный и работающий код может вызывать 
  суицидальные мысли от перспективы в него заглянуть). </p>
  
  <p>А еще хороший код это не пробелы swiftlint, не code coverage 100%, и не релизный паровоз. 
  Хороший код - это здравый смысл и отсутствие горящих дедлайнов. 
  Можно прочесть все книги мира и писать запутанное нечто, а можно просто не успевать сделать 
  хорошо и писать как можно быстрее. С дейдлайнами я помочь не могу, зато могу сформулировать несколько 
  субъективных принципов, которые, на мой взгляд, позволят делать код если не хорошим, то по крайней мере 
  не сильно ужасным. Главное помнить, что вы делаете и зачем. А помогать в этом может простой мысленный эксперимент. 
  Представьте, что код, который вы сейчас пишите, будет передан на ближайшие 2-3 года нескольким командам на аутсорс. 
  В командах будут одни джуны, состав из разных частей света, коммуникации никакой. 
  Но вот, спустя это время, код, а также все, что было написано поверх него, возвращается в ваши заботливые руки. 
  Необходимо собрать его в один суперапп и порадовать своих пользователей. И то, насколько труден будет этот процесс, 
  зависит от того, какие принципы и подходы были заложены в самом начале.</p>

<h2>Технопорно</h2>
  <p>При решении любой задачи стоит очень хорошо продумывать инструменты. Технопроном я называю решения, которые 
  принимаются потому что “стильно, модно, молодежно”, а не из необходимости. Они годятся для рассказов и хвастовства 
  перед другими разработчиками, но не более того. </p>
  
  <p>Прочитав очередную статью или посмотрев доклад, не стоит сразу тянуть увиденное в продукт. 
  Серебряных пуль не существует, а вот неправильно и не к месту примененные подходы встречаются постоянно. 
  Тренируйтесь на кошках (и других пэтах), взвешивайте плюсы и минусы. 
  Помните, что через 3 года ваш выбор к вам вернется (напоминаю про мысленный эксперимент из текста выше).</p>

<h2>Модули</h2>
<p>Под модулем я понимаю логически независимый участок кода. Это может быть как функция без синглтона, так и класс, принимающий все необходимое для своей работы в явном виде. Главное, чтобы была обозначена граница, не выходя за которую можно копипастить (или подключать в виде библиотеки) код в другой проект. Основное правило для модуля - придерживаться принципов единой ответственности и открытости/закрытости.</p>

<p>Звучит как “пишите хорошо, не пишите плохо”, поэтому отмечу пару моментов, облегчающих разработку именно модулей, а не высокосвязного кода:
  <ul>
<li>напишите документацию (что вообще должен модуль делать, в чем смысл его существования) раньше кода, это в принципе неплохая практика, плюс поможет следить за одной ответственностью</li>
<li>обращайте внимание на public и private, по-хорошему приватным должно быть все, что не является интерфейсом (окном во внешний мир)</li>
<li>пишите тесты, хотя бы самые простые, это позволит видеть зависимости</li>
<li>подумайте над разбивкой на подключаемые библиотеки (cocoapods, spm), это позволит указать ответственных за код и не даст его менять любому желающему. Для функции это, конечно, избыточно, но в остальных случаях может быть оправдано.</li>
</ul>

