---
layout: default
---

<h1>Хороший код</h1>
  <p>Прежде чем писать хороший код, нужно определиться, что считать хорошим. 
  Универсальное правило: мой код хороший, код моего коллеги (особенно тот, что достался в “наследство”) - плохой. 
  Эту шутку можно сказать другими словами: чем больнее мне работать с кодом, тем он хуже. 
  Под работой я понимаю как добавление функционала, так и поиск бага, так и просто открыть, 
  посмотреть на логику (это важное уточнение: изолированный и работающий код может вызывать 
  суицидальные мысли от перспективы в него заглянуть). </p>
  
  <p>А еще хороший код это не пробелы swiftlint, не code coverage 100%, и не релизный паровоз. 
  Хороший код - это здравый смысл и отсутствие горящих дедлайнов. 
  Можно прочесть все книги мира и писать запутанное нечто, а можно просто не успевать сделать 
  хорошо и писать как можно быстрее. С дейдлайнами я помочь не могу, зато могу сформулировать несколько 
  субъективных принципов, которые, на мой взгляд, позволят делать код если не хорошим, то по крайней мере 
  не сильно ужасным. Главное помнить, что вы делаете и зачем. А помогать в этом может простой мысленный эксперимент. 
  Представьте, что код, который вы сейчас пишите, будет передан на ближайшие 2-3 года нескольким командам на аутсорс. 
  В командах будут одни джуны, состав из разных частей света, коммуникации никакой. 
  Но вот, спустя это время, код, а также все, что было написано поверх него, возвращается в ваши заботливые руки. 
  Необходимо собрать его в один суперапп и порадовать своих пользователей. И то, насколько труден будет этот процесс, 
  зависит от того, какие принципы и подходы были заложены в самом начале.</p>

<h2>Общие принципы</h2>
<h3>Технопорно</h3>
  <p>При решении любой задачи стоит очень хорошо продумывать инструменты. Технопроном я называю решения, которые 
  принимаются потому что “стильно, модно, молодежно”, а не из необходимости. Они годятся для рассказов и хвастовства 
  перед другими разработчиками, но не более того. </p>
  
  <p>Прочитав очередную статью или посмотрев доклад, не стоит сразу тянуть увиденное в продукт. 
  Серебряных пуль не существует, а вот неправильно и не к месту примененные подходы встречаются постоянно. 
  Тренируйтесь на кошках (и других пэтах), взвешивайте плюсы и минусы. 
  Помните, что через 3 года ваш выбор к вам вернется (напоминаю про мысленный эксперимент из текста выше).</p>

<h3>Модули</h3>
<p>Под модулем я понимаю логически независимый участок кода. Это может быть как функция без синглтона, так и класс, принимающий все необходимое для своей работы в явном виде. Главное, чтобы была обозначена граница, не выходя за которую можно копипастить (или подключать в виде библиотеки) код в другой проект. Основное правило для модуля - придерживаться принципов единой ответственности и открытости/закрытости.</p>

<p>Звучит как “пишите хорошо, не пишите плохо”, поэтому отмечу пару моментов, облегчающих разработку именно модулей, а не высокосвязного кода:
  <ul>
<li>напишите документацию (что вообще должен модуль делать, в чем смысл его существования) раньше кода, это в принципе неплохая практика, плюс поможет следить за одной ответственностью</li>
<li>обращайте внимание на public и private, по-хорошему приватным должно быть все, что не является интерфейсом (окном во внешний мир)</li>
<li>пишите тесты, хотя бы самые простые, это позволит видеть зависимости</li>
<li>подумайте над разбивкой на подключаемые библиотеки (cocoapods, spm), это позволит указать ответственных за код и не даст его менять любому желающему. Для функции это, конечно, избыточно, но в остальных случаях может быть оправдано.</li>
</ul></p>

<h3>Рефакторинг</h3>
<p>Рефакторинг - изменение структуры кода при неизменной внешнем поведении. Я встречал такое определение, и полностью с ним согласен, если приложение не меняется для пользователя, а код был написан (или изменен, удален), то это все рефакторинг. Цель этого процесса - … А вот с целью получается интересней. Невозможно написать код, который будет всегда учитывать изменения требований. Рано или поздно придет задача, которая не будет красиво встраиваться в текущее поведение. И сделать задачу можно двумя способами. Или быстро, подставив костыль под нужный функционал. Или медленно, сначала изменив текущий код так, чтобы задачу можно было решить подготовленным способом, без костылей. Когда я писал про необходимость гибких дедлайнов для качественного кода, я в первую очередь имел в виду именно это. </p>
<p>Старайтесь сначала отрефакторить код для решения задачи, чем закрывать потребности костылями/фиксами. </p>

<h3>Сторонние библиотеки</h3>
<p>Зачем писать свои велосипеды и тратить время в никуда, ведь есть уже готовое, поддерживаемое и проверенное решение. Просто добавь библиотеку! Правда в этом подходе есть ряд оговорок, на которые стоит обращать внимание:
  <ul>
<li>сторонние решения универсальны и функциональны, стоит ли тянуть монстра, если он не будет использоваться и наполовину</li>
<li>сторонние решения увеличивают время компиляции, время запуска приложения и его размер</li>
<li>аргумент про комьюнити принимается только от людей, состоящих в нем (разработчик же будет после добавление либы смотреть за ее новыми версиями и регулярно обновлять, а не забьет в тот же день)</li>
<li>синтаксический сахар = вкусовщина. Этот пункт холиварен, а значит добавление каждой такой зависимости должно обсуждаться</li>
</ul></p>

<p>Мое субъективное мнение - не тащи в проект то, что можно без проблем написать самому. И удачи с хорошим настроением тому, кто будет убирать старые либы (RxSwift, к примеру, очень важная и нужная либа, без нее в 2022 никак не обойтись).
Если выразить это более объективно - не тащите все подряд, а каждый раз думайте, какую задачу вы хотите решить и каким способом/инструментом.</p>

<h2>View</h2>
<h3>Универсальность</h3>
<p>Базовое правило - view занимается отображением, ничего не зная о сути контента. Такой подход позволит переиспользовать view в разных сценариях, и в целом даст возможность составить свой UIKit в <a href="https://bradfrost.com/blog/post/atomic-web-design/">атомарном стиле</a>.</p>
<p>Что это значит, объясню на примере. Допустим, вам нужно реализовать экран настроек, состоящий из 5-10 одинаковых элементов. Каждый элемент - иконка + заголовок, опционально описание. Так как список статичен и мал, достаточно взять UIStackView и сделать некоторую SettingsItemView, с возможностью задать иконку/заголовок/описание. И вот тут и кроется ошибка, так как view прямо в своем названии кричит о том, что именно будет отображаться. Если сделать то же самое, но назвать IconTitleView (или любое другое название), то когда понадобится отобразить такой же контент, достаточно будет просто переиспользовать класс. А еще есть опция, что такой класс уже существует, и будет достаточно взять его.</p>
<p>Делайте фокус не на том, что будет отображаться с точки зрения конкретного экрана/бизнес задачи, а на том, что вообще принципиально будет показано и как.</p>
